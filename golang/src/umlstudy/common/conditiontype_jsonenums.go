// generated by jsonenums -type=ConditionType; DO NOT EDIT

package common

import (
	"encoding/json"
	"fmt"
)

var (
	_ConditionTypeNameToValue = map[string]ConditionType{
		"Less":           Less,
		"LessOrEqual":    LessOrEqual,
		"Equal":          Equal,
		"GreaterOrEqual": GreaterOrEqual,
		"Greater":        Greater,
	}

	_ConditionTypeValueToName = map[ConditionType]string{
		Less:           "Less",
		LessOrEqual:    "LessOrEqual",
		Equal:          "Equal",
		GreaterOrEqual: "GreaterOrEqual",
		Greater:        "Greater",
	}
)

func init() {
	var v ConditionType
	if _, ok := interface{}(v).(fmt.Stringer); ok {
		_ConditionTypeNameToValue = map[string]ConditionType{
			interface{}(Less).(fmt.Stringer).String():           Less,
			interface{}(LessOrEqual).(fmt.Stringer).String():    LessOrEqual,
			interface{}(Equal).(fmt.Stringer).String():          Equal,
			interface{}(GreaterOrEqual).(fmt.Stringer).String(): GreaterOrEqual,
			interface{}(Greater).(fmt.Stringer).String():        Greater,
		}
	}
}

// MarshalJSON is generated so ConditionType satisfies json.Marshaler.
func (r ConditionType) MarshalJSON() ([]byte, error) {
	if s, ok := interface{}(r).(fmt.Stringer); ok {
		return json.Marshal(s.String())
	}
	s, ok := _ConditionTypeValueToName[r]
	if !ok {
		return nil, fmt.Errorf("invalid ConditionType: %d", r)
	}
	return json.Marshal(s)
}

// UnmarshalJSON is generated so ConditionType satisfies json.Unmarshaler.
func (r *ConditionType) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return fmt.Errorf("ConditionType should be a string, got %s", data)
	}
	v, ok := _ConditionTypeNameToValue[s]
	if !ok {
		return fmt.Errorf("invalid ConditionType %q", s)
	}
	*r = v
	return nil
}
